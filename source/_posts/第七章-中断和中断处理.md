---
title: 第七章-中断和中断处理
date: 2019-01-02 19:56:29
tags: 读书笔记
categories:
- 读书笔记
- Linux内核设计与实现
---

1. 由于CPU的速度与外设速度不一致（不在一个数量级上），所以不可能让CPU发出一个请求，然后一直等待外设的回应，于是产生了两种CPU与外设之间的通信方式：中断与轮询。
2. 中断：硬件产生的异步中断
   异常：软件产生的同步中断，如除0/缺页等
3. 特定的中断总是与特定的设备相关联（中断号）
4. 中断服务例程（interrupt service routine），中断随时发生导致ISR随时可能执行，对硬件，希望操作系统需要迅速处理硬件产生的中断；对系统其他部分，希望ISR尽快处理完成，好继续他们的工作，但是有时ISR里需要
   处理大量的数据包，如网卡，所以又不可能执行的很快，这就产生了一个矛盾点。
5. 又想中断运行的快，又想中断处理程序完成的工作量多，怎么办？--->上半部/下半部的概念由此而生。
6. 上半部：所有中断禁止情况下运行
   下半部：开中断运行
7. request_irq可能睡眠，不能用在中断上下文或者其他不允许阻塞的代码中，因为request_irq最终会调到kmalloc函数
8. IRQ_NONE；发生了一个中断，但是这个中断不是我对应的硬件设备产生的；
   IRQ_HANDLED: 发生了一个中断，这个中断确实是我对应的硬件设备产生的。
9. 对于一条中断线上的共享中断，如何区分是否是自己对应的硬件设备产生了中断（dev_id）.
10.中断上下文为什么不能睡眠，而进程上下文就可以？
	进程上下文：current关联当前进程，因此可以睡眠可以调度；
	中断上下文：current指向被中断的进程，但是没有后备进程，无法对它进行再调度，所以不能睡眠
11. 中断处理流程：
	硬件---电信号--->中断控制器---筛选后--->cpu--->跳到中断向量表--->内核调用do_IRQ()--->handle_IRQ_event()--->调用注册的ISR--->返回
12. cat  /proc/interrupts
中断号  CPU  中断控制器  中断源的名字
13. in_interrupt()检测是处在中断上下文还是进程上下文
